{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _handlersDefaultEvent;\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport invariant from 'invariant';\nimport DeviceEventEmitter from \"react-native-web/dist/exports/DeviceEventEmitter\";\nimport { flingHandlerName } from \"./handlers/FlingGestureHandler\";\nimport { forceTouchHandlerName } from \"./handlers/ForceTouchGestureHandler\";\nimport { BaseGesture } from \"./handlers/gestures/gesture\";\nimport { findHandlerByTestID } from \"./handlers/handlersRegistry\";\nimport { longPressHandlerName } from \"./handlers/LongPressGestureHandler\";\nimport { nativeViewHandlerName } from \"./handlers/NativeViewGestureHandler\";\nimport { panHandlerName } from \"./handlers/PanGestureHandler\";\nimport { pinchHandlerName } from \"./handlers/PinchGestureHandler\";\nimport { rotationHandlerName } from \"./handlers/RotationGestureHandler\";\nimport { tapHandlerName } from \"./handlers/TapGestureHandler\";\nimport { State } from \"./State\";\nimport { hasProperty, withPrevAndCurrent } from \"./utils\";\n\nvar fireEvent = function fireEvent(_element, _name) {};\n\ntry {\n  fireEvent = require('@testing-library/react-native').fireEvent;\n} catch (_e) {}\n\nvar handlersDefaultEvents = (_handlersDefaultEvent = {}, _defineProperty(_handlersDefaultEvent, flingHandlerName, {\n  x: 0,\n  y: 0,\n  absoluteX: 0,\n  absoluteY: 0,\n  numberOfPointers: 1\n}), _defineProperty(_handlersDefaultEvent, forceTouchHandlerName, {\n  x: 0,\n  y: 0,\n  absoluteX: 0,\n  absoluteY: 0,\n  force: 1,\n  numberOfPointers: 1\n}), _defineProperty(_handlersDefaultEvent, longPressHandlerName, {\n  x: 0,\n  y: 0,\n  absoluteX: 0,\n  absoluteY: 0,\n  duration: 100,\n  numberOfPointers: 1\n}), _defineProperty(_handlersDefaultEvent, nativeViewHandlerName, {\n  pointerInside: true,\n  numberOfPointers: 1\n}), _defineProperty(_handlersDefaultEvent, panHandlerName, {\n  x: 0,\n  y: 0,\n  absoluteX: 0,\n  absoluteY: 0,\n  translationX: 100,\n  translationY: 0,\n  velocityX: 3,\n  velocityY: 0,\n  numberOfPointers: 1\n}), _defineProperty(_handlersDefaultEvent, pinchHandlerName, {\n  focalX: 0,\n  focalY: 0,\n  scale: 2,\n  velocity: 1,\n  numberOfPointers: 2\n}), _defineProperty(_handlersDefaultEvent, rotationHandlerName, {\n  anchorX: 0,\n  anchorY: 0,\n  rotation: 3.14,\n  velocity: 2,\n  numberOfPointers: 2\n}), _defineProperty(_handlersDefaultEvent, tapHandlerName, {\n  x: 0,\n  y: 0,\n  absoluteX: 0,\n  absoluteY: 0,\n  numberOfPointers: 1\n}), _handlersDefaultEvent);\n\nfunction isGesture(componentOrGesture) {\n  return componentOrGesture instanceof BaseGesture;\n}\n\nfunction wrapWithNativeEvent(event) {\n  return {\n    nativeEvent: event\n  };\n}\n\nfunction fillOldStateChanges(previousEvent, currentEvent) {\n  var isFirstEvent = previousEvent === null;\n\n  if (isFirstEvent) {\n    return _objectSpread({\n      oldState: State.UNDETERMINED\n    }, currentEvent);\n  }\n\n  var isGestureStateEvent = previousEvent.state !== currentEvent.state;\n\n  if (isGestureStateEvent) {\n    return _objectSpread({\n      oldState: previousEvent === null || previousEvent === void 0 ? void 0 : previousEvent.state\n    }, currentEvent);\n  } else {\n    return currentEvent;\n  }\n}\n\nfunction validateStateTransitions(previousEvent, currentEvent) {\n  function stringify(event) {\n    return JSON.stringify(event, null, 2);\n  }\n\n  function errorMsgWithBothEvents(description) {\n    return description + \", invalid event: \" + stringify(currentEvent) + \", previous event: \" + stringify(previousEvent);\n  }\n\n  function errorMsgWithCurrentEvent(description) {\n    return description + \", invalid event: \" + stringify(currentEvent);\n  }\n\n  invariant(hasProperty(currentEvent, 'state'), errorMsgWithCurrentEvent('every event must have state'));\n  var isFirstEvent = previousEvent === null;\n\n  if (isFirstEvent) {\n    invariant(currentEvent.state === State.BEGAN, errorMsgWithCurrentEvent('first event must have BEGAN state'));\n  }\n\n  if (previousEvent !== null) {\n    if (previousEvent.state !== currentEvent.state) {\n      invariant(hasProperty(currentEvent, 'oldState'), errorMsgWithCurrentEvent('when state changes, oldState field should be present'));\n      invariant(currentEvent.oldState === previousEvent.state, errorMsgWithBothEvents(\"when state changes, oldState should be the same as previous event' state\"));\n    }\n  }\n\n  return currentEvent;\n}\n\nfunction fillMissingDefaultsFor(_ref) {\n  var handlerType = _ref.handlerType,\n      handlerTag = _ref.handlerTag;\n  return function (event) {\n    return _objectSpread(_objectSpread(_objectSpread({}, handlersDefaultEvents[handlerType]), event), {}, {\n      handlerTag: handlerTag\n    });\n  };\n}\n\nfunction isDiscreteHandler(handlerType) {\n  return handlerType === 'TapGestureHandler' || handlerType === 'LongPressGestureHandler';\n}\n\nfunction fillMissingStatesTransitions(events, isDiscreteHandler) {\n  var _events2, _events$;\n\n  var _events = _toConsumableArray(events);\n\n  var lastEvent = (_events2 = _events[_events.length - 1]) !== null && _events2 !== void 0 ? _events2 : null;\n  var firstEvent = (_events$ = _events[0]) !== null && _events$ !== void 0 ? _events$ : null;\n  var shouldDuplicateFirstEvent = !isDiscreteHandler && !hasState(State.BEGAN)(firstEvent);\n\n  if (shouldDuplicateFirstEvent) {\n    var duplicated = _objectSpread(_objectSpread({}, firstEvent), {}, {\n      state: State.BEGAN\n    });\n\n    delete duplicated.oldState;\n\n    _events.unshift(duplicated);\n  }\n\n  var shouldDuplicateLastEvent = !hasState(State.END)(lastEvent) || !hasState(State.FAILED)(lastEvent) || !hasState(State.CANCELLED)(lastEvent);\n\n  if (shouldDuplicateLastEvent) {\n    var _duplicated = _objectSpread(_objectSpread({}, lastEvent), {}, {\n      state: State.END\n    });\n\n    delete _duplicated.oldState;\n\n    _events.push(_duplicated);\n  }\n\n  function isWithoutState(event) {\n    return event !== null && !hasProperty(event, 'state');\n  }\n\n  function hasState(state) {\n    return function (event) {\n      return event !== null && event.state === state;\n    };\n  }\n\n  function noEventsLeft(event) {\n    return event === null;\n  }\n\n  function trueFn() {\n    return true;\n  }\n\n  function fillEventsForCurrentState(_ref2) {\n    var _ref2$shouldConsumeEv = _ref2.shouldConsumeEvent,\n        shouldConsumeEvent = _ref2$shouldConsumeEv === void 0 ? trueFn : _ref2$shouldConsumeEv,\n        _ref2$shouldTransitio = _ref2.shouldTransitionToNextState,\n        shouldTransitionToNextState = _ref2$shouldTransitio === void 0 ? trueFn : _ref2$shouldTransitio;\n\n    function peekCurrentEvent() {\n      var _events$2;\n\n      return (_events$2 = _events[0]) !== null && _events$2 !== void 0 ? _events$2 : null;\n    }\n\n    function peekNextEvent() {\n      var _events$3;\n\n      return (_events$3 = _events[1]) !== null && _events$3 !== void 0 ? _events$3 : null;\n    }\n\n    function consumeCurrentEvent() {\n      _events.shift();\n    }\n\n    var currentEvent = peekCurrentEvent();\n    var nextEvent = peekNextEvent();\n    var currentRequiredState = REQUIRED_EVENTS[currentStateIdx];\n    var eventData = {};\n    var shouldUseEvent = shouldConsumeEvent(currentEvent);\n\n    if (shouldUseEvent) {\n      eventData = currentEvent;\n      consumeCurrentEvent();\n    }\n\n    transformedEvents.push(_objectSpread({\n      state: currentRequiredState\n    }, eventData));\n\n    if (shouldTransitionToNextState(nextEvent)) {\n      currentStateIdx++;\n    }\n  }\n\n  var REQUIRED_EVENTS = [State.BEGAN, State.ACTIVE, State.END];\n  var currentStateIdx = 0;\n  var transformedEvents = [];\n  var hasAllStates;\n  var iterations = 0;\n\n  do {\n    var nextRequiredState = REQUIRED_EVENTS[currentStateIdx];\n\n    if (nextRequiredState === State.BEGAN) {\n      fillEventsForCurrentState({\n        shouldConsumeEvent: function shouldConsumeEvent(e) {\n          return isWithoutState(e) || hasState(State.BEGAN)(e);\n        }\n      });\n    } else if (nextRequiredState === State.ACTIVE) {\n      var shouldConsumeEvent = function shouldConsumeEvent(e) {\n        return isWithoutState(e) || hasState(State.ACTIVE)(e);\n      };\n\n      var shouldTransitionToNextState = function shouldTransitionToNextState(nextEvent) {\n        return noEventsLeft(nextEvent) || hasState(State.END)(nextEvent) || hasState(State.FAILED)(nextEvent) || hasState(State.CANCELLED)(nextEvent);\n      };\n\n      fillEventsForCurrentState({\n        shouldConsumeEvent: shouldConsumeEvent,\n        shouldTransitionToNextState: shouldTransitionToNextState\n      });\n    } else if (nextRequiredState === State.END) {\n      fillEventsForCurrentState({});\n    }\n\n    hasAllStates = currentStateIdx === REQUIRED_EVENTS.length;\n    invariant(iterations++ <= 500, 'exceeded max number of iterations, please report a bug in RNGH repository with your test case');\n  } while (!hasAllStates);\n\n  return transformedEvents;\n}\n\nfunction getHandlerData(componentOrGesture) {\n  if (isGesture(componentOrGesture)) {\n    var gesture = componentOrGesture;\n    return {\n      emitEvent: function emitEvent(eventName, args) {\n        DeviceEventEmitter.emit(eventName, args.nativeEvent);\n      },\n      handlerType: gesture.handlerName,\n      handlerTag: gesture.handlerTag\n    };\n  }\n\n  var gestureHandlerComponent = componentOrGesture;\n  return {\n    emitEvent: function emitEvent(eventName, args) {\n      fireEvent(gestureHandlerComponent, eventName, args);\n    },\n    handlerType: gestureHandlerComponent.props.handlerType,\n    handlerTag: gestureHandlerComponent.props.handlerTag\n  };\n}\n\nexport function fireGestureHandler(componentOrGesture) {\n  var eventList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  var _getHandlerData = getHandlerData(componentOrGesture),\n      emitEvent = _getHandlerData.emitEvent,\n      handlerType = _getHandlerData.handlerType,\n      handlerTag = _getHandlerData.handlerTag;\n\n  var _ = fillMissingStatesTransitions(eventList, isDiscreteHandler(handlerType));\n\n  _ = _.map(fillMissingDefaultsFor({\n    handlerTag: handlerTag,\n    handlerType: handlerType\n  }));\n  _ = withPrevAndCurrent(_, fillOldStateChanges);\n  _ = withPrevAndCurrent(_, validateStateTransitions);\n  _ = _.map(wrapWithNativeEvent);\n  var events = _;\n  var firstEvent = events.shift();\n  emitEvent('onGestureHandlerStateChange', firstEvent);\n  var lastSentEvent = firstEvent;\n\n  for (var _iterator = _createForOfIteratorHelperLoose(events), _step; !(_step = _iterator()).done;) {\n    var event = _step.value;\n    var hasChangedState = lastSentEvent.nativeEvent.state !== event.nativeEvent.state;\n\n    if (hasChangedState) {\n      emitEvent('onGestureHandlerStateChange', event);\n    } else {\n      emitEvent('onGestureHandlerEvent', event);\n    }\n\n    lastSentEvent = event;\n  }\n}\nexport function getByGestureTestId(testID) {\n  var handler = findHandlerByTestID(testID);\n\n  if (handler === null) {\n    throw new Error(\"Handler with id: '\" + testID + \"' cannot be found\");\n  }\n\n  return handler;\n}","map":{"version":3,"sources":["jestUtils.ts"],"names":["fireEvent","require","handlersDefaultEvents","x","y","absoluteX","absoluteY","numberOfPointers","force","duration","pointerInside","translationX","translationY","velocityX","velocityY","focalX","focalY","scale","velocity","anchorX","anchorY","rotation","componentOrGesture","nativeEvent","event","isFirstEvent","previousEvent","oldState","State","currentEvent","isGestureStateEvent","JSON","description","stringify","invariant","hasProperty","errorMsgWithCurrentEvent","errorMsgWithBothEvents","handlerTag","handlerType","_events","lastEvent","firstEvent","shouldDuplicateFirstEvent","hasState","duplicated","state","BEGAN","shouldDuplicateLastEvent","END","shouldConsumeEvent","shouldTransitionToNextState","trueFn","peekCurrentEvent","nextEvent","peekNextEvent","currentRequiredState","REQUIRED_EVENTS","eventData","shouldUseEvent","consumeCurrentEvent","transformedEvents","currentStateIdx","iterations","nextRequiredState","fillEventsForCurrentState","e","isWithoutState","noEventsLeft","hasAllStates","isGesture","gesture","emitEvent","DeviceEventEmitter","args","gestureHandlerComponent","eventList","getHandlerData","_","fillMissingStatesTransitions","isDiscreteHandler","fillMissingDefaultsFor","withPrevAndCurrent","events","lastSentEvent","hasChangedState","handler","findHandlerByTestID"],"mappings":"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","sourcesContent":["import invariant from 'invariant';\nimport { DeviceEventEmitter } from 'react-native';\nimport { ReactTestInstance } from 'react-test-renderer';\nimport {\n  FlingGestureHandler,\n  FlingGestureHandlerEventPayload,\n  flingHandlerName,\n} from './handlers/FlingGestureHandler';\nimport {\n  ForceTouchGestureHandler,\n  ForceTouchGestureHandlerEventPayload,\n  forceTouchHandlerName,\n} from './handlers/ForceTouchGestureHandler';\nimport {\n  BaseGestureHandlerProps,\n  GestureEvent,\n  HandlerStateChangeEvent,\n} from './handlers/gestureHandlerCommon';\nimport { FlingGesture } from './handlers/gestures/flingGesture';\nimport { ForceTouchGesture } from './handlers/gestures/forceTouchGesture';\nimport { BaseGesture, GestureType } from './handlers/gestures/gesture';\nimport { LongPressGesture } from './handlers/gestures/longPressGesture';\nimport { NativeGesture } from './handlers/gestures/nativeGesture';\nimport { PanGesture } from './handlers/gestures/panGesture';\nimport { PinchGesture } from './handlers/gestures/pinchGesture';\nimport { RotationGesture } from './handlers/gestures/rotationGesture';\nimport { TapGesture } from './handlers/gestures/tapGesture';\nimport { findHandlerByTestID } from './handlers/handlersRegistry';\nimport {\n  LongPressGestureHandler,\n  LongPressGestureHandlerEventPayload,\n  longPressHandlerName,\n} from './handlers/LongPressGestureHandler';\nimport {\n  NativeViewGestureHandler,\n  NativeViewGestureHandlerPayload,\n  nativeViewHandlerName,\n} from './handlers/NativeViewGestureHandler';\nimport {\n  PanGestureHandler,\n  PanGestureHandlerEventPayload,\n  panHandlerName,\n} from './handlers/PanGestureHandler';\nimport {\n  PinchGestureHandler,\n  PinchGestureHandlerEventPayload,\n  pinchHandlerName,\n} from './handlers/PinchGestureHandler';\nimport {\n  RotationGestureHandler,\n  RotationGestureHandlerEventPayload,\n  rotationHandlerName,\n} from './handlers/RotationGestureHandler';\nimport {\n  TapGestureHandler,\n  TapGestureHandlerEventPayload,\n  tapHandlerName,\n} from './handlers/TapGestureHandler';\nimport { State } from './State';\nimport { hasProperty, withPrevAndCurrent } from './utils';\n\n// load fireEvent conditionally, so RNGH may be used in setups without testing-library\nlet fireEvent = (\n  _element: ReactTestInstance,\n  _name: string,\n  ..._data: any[]\n) => {\n  // NOOP\n};\n\ntry {\n  // eslint-disable-next-line @typescript-eslint/no-var-requires\n  fireEvent = require('@testing-library/react-native').fireEvent;\n} catch (_e) {\n  // do nothing if not available\n}\n\ntype GestureHandlerTestEvent<\n  TEventPayload extends Record<string, unknown> = Record<string, unknown>\n> = (\n  | GestureEvent<TEventPayload>\n  | HandlerStateChangeEvent<TEventPayload>\n)['nativeEvent'];\n\ntype HandlerNames = keyof DefaultEventsMapping;\n\ntype WithNumberOfPointers<T> = {\n  [P in keyof T]: T[P] & { numberOfPointers: number };\n};\ntype DefaultEventsMapping = WithNumberOfPointers<{\n  [flingHandlerName]: FlingGestureHandlerEventPayload;\n  [forceTouchHandlerName]: ForceTouchGestureHandlerEventPayload;\n  [longPressHandlerName]: LongPressGestureHandlerEventPayload;\n  [nativeViewHandlerName]: NativeViewGestureHandlerPayload;\n  [panHandlerName]: PanGestureHandlerEventPayload;\n  [pinchHandlerName]: PinchGestureHandlerEventPayload;\n  [rotationHandlerName]: RotationGestureHandlerEventPayload;\n  [tapHandlerName]: TapGestureHandlerEventPayload;\n}>;\n\nconst handlersDefaultEvents: DefaultEventsMapping = {\n  [flingHandlerName]: {\n    x: 0,\n    y: 0,\n    absoluteX: 0,\n    absoluteY: 0,\n    numberOfPointers: 1,\n  },\n  [forceTouchHandlerName]: {\n    x: 0,\n    y: 0,\n    absoluteX: 0,\n    absoluteY: 0,\n    force: 1,\n    numberOfPointers: 1,\n  },\n  [longPressHandlerName]: {\n    x: 0,\n    y: 0,\n    absoluteX: 0,\n    absoluteY: 0,\n    duration: 100,\n    numberOfPointers: 1,\n  },\n  [nativeViewHandlerName]: {\n    pointerInside: true,\n    numberOfPointers: 1,\n  },\n  [panHandlerName]: {\n    x: 0,\n    y: 0,\n    absoluteX: 0,\n    absoluteY: 0,\n    translationX: 100,\n    translationY: 0,\n    velocityX: 3,\n    velocityY: 0,\n    numberOfPointers: 1,\n  },\n  [pinchHandlerName]: {\n    focalX: 0,\n    focalY: 0,\n    scale: 2,\n    velocity: 1,\n    numberOfPointers: 2,\n  },\n  [rotationHandlerName]: {\n    anchorX: 0,\n    anchorY: 0,\n    rotation: 3.14,\n    velocity: 2,\n    numberOfPointers: 2,\n  },\n  [tapHandlerName]: {\n    x: 0,\n    y: 0,\n    absoluteX: 0,\n    absoluteY: 0,\n    numberOfPointers: 1,\n  },\n};\n\nfunction isGesture(\n  componentOrGesture: ReactTestInstance | GestureType\n): componentOrGesture is GestureType {\n  return componentOrGesture instanceof BaseGesture;\n}\n\ninterface WrappedGestureHandlerTestEvent {\n  nativeEvent: GestureHandlerTestEvent;\n}\nfunction wrapWithNativeEvent(\n  event: GestureHandlerTestEvent\n): WrappedGestureHandlerTestEvent {\n  return { nativeEvent: event };\n}\n\nfunction fillOldStateChanges(\n  previousEvent: GestureHandlerTestEvent | null,\n  currentEvent: Omit<GestureHandlerTestEvent, 'oldState'>\n): GestureHandlerTestEvent {\n  const isFirstEvent = previousEvent === null;\n  if (isFirstEvent) {\n    return {\n      oldState: State.UNDETERMINED,\n      ...currentEvent,\n    } as GestureHandlerTestEvent;\n  }\n\n  const isGestureStateEvent = previousEvent.state !== currentEvent.state;\n  if (isGestureStateEvent) {\n    return {\n      oldState: previousEvent?.state,\n      ...currentEvent,\n    } as GestureHandlerTestEvent;\n  } else {\n    return currentEvent as GestureHandlerTestEvent;\n  }\n}\n\ntype EventWithStates = Partial<\n  Pick<GestureHandlerTestEvent, 'oldState' | 'state'>\n>;\nfunction validateStateTransitions(\n  previousEvent: EventWithStates | null,\n  currentEvent: EventWithStates\n) {\n  function stringify(event: Record<string, unknown> | null) {\n    return JSON.stringify(event, null, 2);\n  }\n  function errorMsgWithBothEvents(description: string) {\n    return `${description}, invalid event: ${stringify(\n      currentEvent\n    )}, previous event: ${stringify(previousEvent)}`;\n  }\n\n  function errorMsgWithCurrentEvent(description: string) {\n    return `${description}, invalid event: ${stringify(currentEvent)}`;\n  }\n\n  invariant(\n    hasProperty(currentEvent, 'state'),\n    errorMsgWithCurrentEvent('every event must have state')\n  );\n\n  const isFirstEvent = previousEvent === null;\n  if (isFirstEvent) {\n    invariant(\n      currentEvent.state === State.BEGAN,\n      errorMsgWithCurrentEvent('first event must have BEGAN state')\n    );\n  }\n\n  if (previousEvent !== null) {\n    if (previousEvent.state !== currentEvent.state) {\n      invariant(\n        hasProperty(currentEvent, 'oldState'),\n        errorMsgWithCurrentEvent(\n          'when state changes, oldState field should be present'\n        )\n      );\n      invariant(\n        currentEvent.oldState === previousEvent.state,\n        errorMsgWithBothEvents(\n          \"when state changes, oldState should be the same as previous event' state\"\n        )\n      );\n    }\n  }\n\n  return currentEvent;\n}\n\ntype EventWithoutStates = Omit<GestureHandlerTestEvent, 'oldState' | 'state'>;\ninterface HandlerInfo {\n  handlerType: HandlerNames;\n  handlerTag: number;\n}\nfunction fillMissingDefaultsFor({\n  handlerType,\n  handlerTag,\n}: HandlerInfo): (\n  event: Partial<GestureHandlerTestEvent>\n) => EventWithoutStates {\n  return (event) => {\n    return {\n      ...handlersDefaultEvents[handlerType],\n      ...event,\n      handlerTag,\n    };\n  };\n}\n\nfunction isDiscreteHandler(handlerType: HandlerNames) {\n  return (\n    handlerType === 'TapGestureHandler' ||\n    handlerType === 'LongPressGestureHandler'\n  );\n}\n\nfunction fillMissingStatesTransitions(\n  events: EventWithoutStates[],\n  isDiscreteHandler: boolean\n): EventWithoutStates[] {\n  type Event = EventWithoutStates | null;\n  const _events = [...events];\n  const lastEvent = _events[_events.length - 1] ?? null;\n  const firstEvent = _events[0] ?? null;\n\n  const shouldDuplicateFirstEvent =\n    !isDiscreteHandler && !hasState(State.BEGAN)(firstEvent);\n  if (shouldDuplicateFirstEvent) {\n    const duplicated = { ...firstEvent, state: State.BEGAN };\n    // @ts-ignore badly typed, property may exist and we don't want to copy it\n    delete duplicated.oldState;\n    _events.unshift(duplicated);\n  }\n\n  const shouldDuplicateLastEvent =\n    !hasState(State.END)(lastEvent) ||\n    !hasState(State.FAILED)(lastEvent) ||\n    !hasState(State.CANCELLED)(lastEvent);\n\n  if (shouldDuplicateLastEvent) {\n    const duplicated = { ...lastEvent, state: State.END };\n    // @ts-ignore badly typed, property may exist and we don't want to copy it\n    delete duplicated.oldState;\n    _events.push(duplicated);\n  }\n\n  function isWithoutState(event: Event) {\n    return event !== null && !hasProperty(event, 'state');\n  }\n  function hasState(state: State) {\n    return (event: Event) => event !== null && event.state === state;\n  }\n  function noEventsLeft(event: Event) {\n    return event === null;\n  }\n\n  function trueFn() {\n    return true;\n  }\n  interface Args {\n    shouldConsumeEvent?: (event: Event) => boolean;\n    shouldTransitionToNextState?: (nextEvent: Event) => boolean;\n  }\n  function fillEventsForCurrentState({\n    shouldConsumeEvent = trueFn,\n    shouldTransitionToNextState = trueFn,\n  }: Args) {\n    function peekCurrentEvent(): Event {\n      return _events[0] ?? null;\n    }\n    function peekNextEvent(): Event {\n      return _events[1] ?? null;\n    }\n    function consumeCurrentEvent() {\n      _events.shift();\n    }\n    const currentEvent = peekCurrentEvent();\n    const nextEvent = peekNextEvent();\n    const currentRequiredState = REQUIRED_EVENTS[currentStateIdx];\n\n    let eventData = {};\n    const shouldUseEvent = shouldConsumeEvent(currentEvent);\n    if (shouldUseEvent) {\n      eventData = currentEvent!;\n      consumeCurrentEvent();\n    }\n    transformedEvents.push({ state: currentRequiredState, ...eventData });\n    if (shouldTransitionToNextState(nextEvent)) {\n      currentStateIdx++;\n    }\n  }\n\n  const REQUIRED_EVENTS = [State.BEGAN, State.ACTIVE, State.END];\n\n  let currentStateIdx = 0;\n  const transformedEvents: EventWithoutStates[] = [];\n  let hasAllStates;\n  let iterations = 0;\n  do {\n    const nextRequiredState = REQUIRED_EVENTS[currentStateIdx];\n    if (nextRequiredState === State.BEGAN) {\n      fillEventsForCurrentState({\n        shouldConsumeEvent: (e: Event) =>\n          isWithoutState(e) || hasState(State.BEGAN)(e),\n      });\n    } else if (nextRequiredState === State.ACTIVE) {\n      const shouldConsumeEvent = (e: Event) =>\n        isWithoutState(e) || hasState(State.ACTIVE)(e);\n      const shouldTransitionToNextState = (nextEvent: Event) =>\n        noEventsLeft(nextEvent) ||\n        hasState(State.END)(nextEvent) ||\n        hasState(State.FAILED)(nextEvent) ||\n        hasState(State.CANCELLED)(nextEvent);\n\n      fillEventsForCurrentState({\n        shouldConsumeEvent,\n        shouldTransitionToNextState,\n      });\n    } else if (nextRequiredState === State.END) {\n      fillEventsForCurrentState({});\n    }\n    hasAllStates = currentStateIdx === REQUIRED_EVENTS.length;\n\n    invariant(\n      iterations++ <= 500,\n      'exceeded max number of iterations, please report a bug in RNGH repository with your test case'\n    );\n  } while (!hasAllStates);\n\n  return transformedEvents;\n}\n\ntype EventEmitter = (\n  eventName: string,\n  args: { nativeEvent: GestureHandlerTestEvent }\n) => void;\ninterface HandlerData {\n  emitEvent: EventEmitter;\n  handlerType: HandlerNames;\n  handlerTag: number;\n}\nfunction getHandlerData(\n  componentOrGesture: ReactTestInstance | GestureType\n): HandlerData {\n  if (isGesture(componentOrGesture)) {\n    const gesture = componentOrGesture;\n    return {\n      emitEvent: (eventName, args) => {\n        DeviceEventEmitter.emit(eventName, args.nativeEvent);\n      },\n      handlerType: gesture.handlerName as HandlerNames,\n      handlerTag: gesture.handlerTag,\n    };\n  }\n  const gestureHandlerComponent = componentOrGesture;\n  return {\n    emitEvent: (eventName, args) => {\n      fireEvent(gestureHandlerComponent, eventName, args);\n    },\n    handlerType: gestureHandlerComponent.props.handlerType as HandlerNames,\n    handlerTag: gestureHandlerComponent.props.handlerTag as number,\n  };\n}\ntype AllGestures =\n  | TapGesture\n  | PanGesture\n  | LongPressGesture\n  | RotationGesture\n  | PinchGesture\n  | FlingGesture\n  | ForceTouchGesture\n  | NativeGesture;\n\ntype AllHandlers =\n  | TapGestureHandler\n  | PanGestureHandler\n  | LongPressGestureHandler\n  | RotationGestureHandler\n  | PinchGestureHandler\n  | FlingGestureHandler\n  | ForceTouchGestureHandler\n  | NativeViewGestureHandler;\n\n// prettier-ignore\ntype ClassComponentConstructor<P> = new (props: P) => React.Component<P, any, any>;\n\ntype ExtractPayloadFromProps<T> = T extends BaseGestureHandlerProps<\n  infer TPayload\n>\n  ? TPayload\n  : never;\n\ntype ExtractConfig<T> = T extends BaseGesture<infer TGesturePayload>\n  ? TGesturePayload\n  : T extends ClassComponentConstructor<infer THandlerProps>\n  ? ExtractPayloadFromProps<THandlerProps>\n  : Record<string, unknown>;\n\nexport function fireGestureHandler<THandler extends AllGestures | AllHandlers>(\n  componentOrGesture: ReactTestInstance | GestureType,\n  eventList: Partial<GestureHandlerTestEvent<ExtractConfig<THandler>>>[] = []\n): void {\n  const { emitEvent, handlerType, handlerTag } = getHandlerData(\n    componentOrGesture\n  );\n\n  let _ = fillMissingStatesTransitions(\n    eventList,\n    isDiscreteHandler(handlerType)\n  );\n  _ = _.map(fillMissingDefaultsFor({ handlerTag, handlerType }));\n  _ = withPrevAndCurrent(_, fillOldStateChanges);\n  _ = withPrevAndCurrent(_, validateStateTransitions);\n  // @ts-ignore TODO\n  _ = _.map(wrapWithNativeEvent);\n\n  const events = (_ as unknown) as WrappedGestureHandlerTestEvent[];\n\n  const firstEvent = events.shift()!;\n\n  emitEvent('onGestureHandlerStateChange', firstEvent);\n  let lastSentEvent = firstEvent;\n  for (const event of events) {\n    const hasChangedState =\n      lastSentEvent.nativeEvent.state !== event.nativeEvent.state;\n\n    if (hasChangedState) {\n      emitEvent('onGestureHandlerStateChange', event);\n    } else {\n      emitEvent('onGestureHandlerEvent', event);\n    }\n    lastSentEvent = event;\n  }\n}\n\nexport function getByGestureTestId(testID: string) {\n  const handler = findHandlerByTestID(testID);\n  if (handler === null) {\n    throw new Error(`Handler with id: '${testID}' cannot be found`);\n  }\n  return handler;\n}\n"]},"metadata":{},"sourceType":"module"}